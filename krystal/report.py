"""
Report Generator - Creates Markdown test reports
"""

from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any
from krystal.config import ReportConfig


class ReportGenerator:
    """Generates Markdown test reports"""

    def __init__(self, config: ReportConfig = None):
        """
        Initialize report generator

        Args:
            config: Report configuration
        """
        self.config = config or ReportConfig()

    def generate(self, results: List[Dict[str, Any]], output_path: str = None) -> str:
        """
        Generate Markdown report from test results

        Args:
            results: List of test results
            output_path: Output file path (optional)

        Returns:
            Path to generated report file
        """
        # Calculate summary statistics
        total = len(results)
        passed = sum(1 for r in results if r.get("success", False))
        failed = total - passed

        # Build report content
        lines = []

        # Header
        lines.extend(
            [
                "# Krystal Test Report",
                "",
                f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                f"**Environment:** {results[0].get('environment', 'unknown') if results else 'unknown'}",
                "",
                "---",
                "",
            ]
        )

        # Executive Summary
        lines.extend(
            [
                "## Executive Summary",
                "",
                f"| Metric | Value |",
                f"|--------|-------|",
                f"| Total Services | {total} |",
                f"| Passed | {passed} ‚úÖ |",
                f"| Failed | {failed} ‚ùå |",
                f"| Pass Rate | {(passed / total * 100) if total > 0 else 0:.1f}% |",
                "",
            ]
        )

        # Service Results
        lines.extend(
            [
                "## Service Test Results",
                "",
            ]
        )

        for result in results:
            service = result.get("service", "Unknown")
            success = result.get("success", False)
            batch_id = result.get("batch_id", "N/A")
            timestamp = result.get("timestamp", "N/A")

            status_icon = "‚úÖ" if success else "‚ùå"

            lines.extend(
                [
                    f"### {status_icon} {service}",
                    "",
                    f"- **Status:** {'PASSED' if success else 'FAILED'}",
                    f"- **Batch ID:** {batch_id}",
                    f"- **Timestamp:** {timestamp}",
                    "",
                ]
            )

            if not success and "error" in result:
                lines.extend(
                    [
                        "**Error:**",
                        "",
                        f"```",
                        f"{result['error']}",
                        f"```",
                        "",
                    ]
                )

            lines.append("---")
            lines.append("")

        # Detailed Results (if enabled)
        if self.config.include_details:
            lines.extend(
                [
                    "## Detailed Results",
                    "",
                    "```json",
                ]
            )

            for result in results:
                lines.append(str(result))

            lines.extend(
                [
                    "```",
                    "",
                ]
            )

        # Footer
        lines.extend(
            [
                "---",
                "",
                f"*Report generated by Krystal v1.0.0*",
                "",
            ]
        )

        # Write report to file
        content = "\n".join(lines)

        if output_path is None:
            # Generate default filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = (
                Path(self.config.output_path) / f"krystal_report_{timestamp}.md"
            )
        else:
            output_path = Path(output_path)

        # Ensure directory exists
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

        import logging

        logger = logging.getLogger(__name__)
        logger.info(f"üìÑ Report generated: {output_path}")

        return str(output_path)
